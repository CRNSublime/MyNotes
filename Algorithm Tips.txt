
 希尔排序：
 
  将数组内所有元素按照 增量 D 分组， 对每组的数据实行 插入排序；  之后不断减小增量，再次排序；直到增量减少到 1 整个数组被分成一组 再次排序就完成了整个数组的排序；
  
  例如：  数组初始状态为     9    1    2    5    7    4    8    6    3    5                 按照增量 D = 5 分组；  （也就是隔 5 个数的两个数被分为一组  ）
              第一次排序为        4    1    2    3    5    9    8    6    5    7                 被分成 5 组 如下：（9-4），（1-8），（2-6），（5-3），（7-5）
              第二次排序为        2    1    4    3    5    6    5    7    8    9                 按照增量 D = 5/2 取整 = 2 分组；
              第三次排序为        1    2    3    4    5    5    6    7    8    9                 按照增量 D = 2/2 = 1 分组；
              
  选择排序：
  
  找出数组内所有元素最小值 放到 数组 首位，接着找剩下的最小值放到数组第二位，以此类推 最终完成 数组的排序；
  
  for（int i=0； i<Length - 1； i++)
  {
      for( int j= i; j < Length; j++)
      {
          if( a[ i ] > a [  j ])
          {
               temp = a[ j ];
               a[  j ] = a[ i ];
               a[ i ] = temp;     
          }
      }
  }
  
  冒泡排序：
  
  每次将数组相邻的两个数作比较，每一趟就能把最大的那个数排到最后，就像冒泡泡一样...
  
  for（int i=0； i<Length - 1； i++)
  {
      for( int j= 0; j < Length - 1; j++)
      {
          if( a[ j ] > a [  j+1 ])
          {
               temp = a[ j ];
               a[  j ] = a[ j+1 ];
               a[ j+1 ] = temp;     
          }
      }
  }
  
  插入排序 ：
  
  对于数组中的元素　左边的元素看做为有序的，从索引１开始依次把右边的数据插入到左边合适的位置中。
  例如：　　原始数据　　７　６　９　８　５　１　　　从６开始假定左边的元素为有序
  　　　　　第一轮：　　６　７　９　８　５　１　　　排好序　接着依次往后
  　　　　　第二轮：　　６　７　９　８　５　１　　　因为　９　比前面排好序的６７都大　所以不用
  　　　　　第三轮：　　６　７　８　９　５　１
  　　　　　第四轮：　　５　６　７　８　９　１
  　　　　　第五轮：　　１　５　６　７　８　９　　　完成
  
  
  
  